From c77b5adfb3f94762a08554d1b4d75f6cbd8a6abe Mon Sep 17 00:00:00 2001
From: Ido Schimmel <idosch@nvidia.com>
Date: Tue, 12 Oct 2021 16:25:17 +0300
Subject: [PATCH 18/35] sff-8636: Initialize SFF-8636 memory map

The SFF-8636 memory map [1] consists of Lower Memory and Upper Memory.

The content of the Lower Memory is fixed and can be addressed using an
offset between 0 and 127 (inclusive).

The Upper Memory is variable and optional and can be addressed by
specifying a page number and an offset between 128 and 255 (inclusive).

Create a structure describing this memory map and initialize it with
pointers to available pages.

In the IOCTL path, the structure holds pointers to regions of the
continuous buffer passed to user space via the 'ETHTOOL_GMODULEEEPROM'
command.

In the netlink path, the structure holds pointers to individual pages
passed to user space via the 'MODULE_EEPROM_GET' message.

This structure will later allow us to consolidate the IOCTL and netlink
parsing code paths and also easily support additional EEPROM pages, when
needed.

[1] SFF-8636 Rev. 2.10a, pag. 30, section 6.1, Figure 6-1

Signed-off-by: Ido Schimmel <idosch@nvidia.com>
---
 qsfp.c | 65 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 65 insertions(+)

diff --git a/qsfp.c b/qsfp.c
index dc6407d3ef6f..80000d40f6e8 100644
--- a/qsfp.c
+++ b/qsfp.c
@@ -60,6 +60,15 @@
 #include "qsfp.h"
 #include "cmis.h"
 
+struct sff8636_memory_map {
+	const __u8 *lower_memory;
+	const __u8 *upper_memory[4];
+#define page_00h upper_memory[0x0]
+#define page_03h upper_memory[0x3]
+};
+
+#define SFF8636_PAGE_SIZE	0x80
+
 #define MAX_DESC_SIZE	42
 
 static struct sff8636_aw_flags {
@@ -853,13 +862,40 @@ static void sff8636_show_page_zero(const __u8 *id)
 
 }
 
+static void sff8636_memory_map_init_buf(struct sff8636_memory_map *map,
+					const __u8 *id, __u32 eeprom_len)
+{
+	/* Lower Memory and Page 00h are always present.
+	 *
+	 * Offset into Upper Memory is between page size and twice the page
+	 * size. Therefore, set the base address of each page to base address
+	 * plus page size multiplied by the page number.
+	 */
+	map->lower_memory = id;
+	map->page_00h = id;
+
+	/* Page 03h is only present when the module memory model is paged and
+	 * not flat and when we got a big enough buffer from the kernel.
+	 */
+	if (map->lower_memory[SFF8636_STATUS_2_OFFSET] &
+	    SFF8636_STATUS_PAGE_3_PRESENT ||
+	    eeprom_len != ETH_MODULE_SFF_8636_MAX_LEN)
+		return;
+
+	map->page_03h = id + 3 * SFF8636_PAGE_SIZE;
+}
+
 void sff8636_show_all_ioctl(const __u8 *id, __u32 eeprom_len)
 {
+	struct sff8636_memory_map map = {};
+
 	if (id[SFF8636_ID_OFFSET] == SFF8024_ID_QSFP_DD) {
 		cmis_show_all_ioctl(id);
 		return;
 	}
 
+	sff8636_memory_map_init_buf(&map, id, eeprom_len);
+
 	sff8636_show_identifier(id);
 	switch (id[SFF8636_ID_OFFSET]) {
 	case SFF8024_ID_QSFP:
@@ -871,9 +907,38 @@ void sff8636_show_all_ioctl(const __u8 *id, __u32 eeprom_len)
 	}
 }
 
+static void
+sff8636_memory_map_init_pages(struct sff8636_memory_map *map,
+			      const struct ethtool_module_eeprom *page_zero,
+			      const struct ethtool_module_eeprom *page_three)
+{
+	/* Lower Memory and Page 00h are always present.
+	 *
+	 * Offset into Upper Memory is between page size and twice the page
+	 * size. Therefore, set the base address of each page to its base
+	 * address minus page size. For Page 00h, this is the address of the
+	 * Lower Memory.
+	 */
+	map->lower_memory = page_zero->data;
+	map->page_00h = page_zero->data;
+
+	/* Page 03h is only present when the module memory model is paged and
+	 * not flat.
+	 */
+	if (map->lower_memory[SFF8636_STATUS_2_OFFSET] &
+	    SFF8636_STATUS_PAGE_3_PRESENT)
+		return;
+
+	map->page_03h = page_three->data - SFF8636_PAGE_SIZE;
+}
+
 void sff8636_show_all_nl(const struct ethtool_module_eeprom *page_zero,
 			 const struct ethtool_module_eeprom *page_three)
 {
+	struct sff8636_memory_map map = {};
+
+	sff8636_memory_map_init_pages(&map, page_zero, page_three);
+
 	sff8636_show_identifier(page_zero->data);
 	sff8636_show_page_zero(page_zero->data);
 	if (page_three)
-- 
2.35.1

